{"remainingRequest":"/Users/wangluna/wln/vueSpace/vue-ergeng/node_modules/thread-loader/dist/cjs.js!/Users/wangluna/wln/vueSpace/vue-ergeng/node_modules/babel-loader/lib/index.js??ref--16-2!/Users/wangluna/wln/vueSpace/vue-ergeng/node_modules/cache-loader/dist/cjs.js??ref--0-0!/Users/wangluna/wln/vueSpace/vue-ergeng/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/wangluna/wln/vueSpace/vue-ergeng/node_modules/cube-ui/src/components/slide/slide.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/wangluna/wln/vueSpace/vue-ergeng/node_modules/cube-ui/src/components/slide/slide.vue","mtime":499162500000},{"path":"/Users/wangluna/wln/vueSpace/vue-ergeng/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/wangluna/wln/vueSpace/vue-ergeng/node_modules/thread-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/wangluna/wln/vueSpace/vue-ergeng/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/wangluna/wln/vueSpace/vue-ergeng/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/wangluna/wln/vueSpace/vue-ergeng/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.number.constructor\";\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nimport CubeSlideItem from \"./slide-item.vue\";\nimport BScroll from 'better-scroll';\nimport scrollMixin from \"../../common/mixins/scroll\";\nimport deprecatedMixin from \"../../common/mixins/deprecated\";\nvar COMPONENT_NAME = 'cube-slide';\nvar EVENT_CHANGE = 'change';\nvar EVENT_SELECT = 'click';\nvar EVENT_SCROLL_END = 'scroll-end';\nvar EVENT_SCROLL = 'scroll';\nvar DIRECTION_H = 'horizontal';\nvar DIRECTION_V = 'vertical';\nvar DEFAULT_OPTIONS = {\n  momentum: false,\n  click: true,\n  observeDOM: false,\n  bounce: false\n};\nexport default {\n  name: COMPONENT_NAME,\n  mixins: [scrollMixin, deprecatedMixin],\n  props: {\n    data: {\n      type: Array,\n      default: function _default() {\n        /* istanbul ignore next */\n        return [];\n      }\n    },\n    initialIndex: {\n      type: Number,\n      default: 0\n    },\n    loop: {\n      type: Boolean,\n      default: true\n    },\n    threshold: {\n      type: Number,\n      default: 0.3\n    },\n    speed: {\n      type: Number,\n      default: 400\n    },\n    autoPlay: {\n      type: Boolean,\n      default: true\n    },\n    interval: {\n      type: Number,\n      default: 4000\n    },\n    showDots: {\n      type: Boolean,\n      default: true\n    },\n    direction: {\n      type: String,\n      default: DIRECTION_H\n    },\n    // The props allowVertical, stopPropagation could be removed in next minor version.\n    allowVertical: {\n      type: Boolean,\n      default: undefined,\n      deprecated: {\n        replacedBy: 'options'\n      }\n    },\n    stopPropagation: {\n      type: Boolean,\n      default: undefined,\n      deprecated: {\n        replacedBy: 'options'\n      }\n    },\n    refreshResetCurrent: {\n      type: Boolean,\n      default: true\n    }\n  },\n  data: function data() {\n    return {\n      dots: 0,\n      currentPageIndex: this.initialIndex || 0\n    };\n  },\n  created: function created() {\n    var _this = this;\n\n    this._dataWatchers = [];\n    var needRefreshProps = ['data', 'loop', 'autoPlay', 'options.eventPassthrough', 'threshold', 'speed', 'allowVertical'];\n    needRefreshProps.forEach(function (key) {\n      _this._dataWatchers.push(_this.$watch(key, function () {\n        // To fix the render bug when add items since loop.\n        if (key === 'data') {\n          _this._destroy();\n        }\n        /* istanbul ignore next */\n\n\n        _this.$nextTick(function () {\n          _this.refresh();\n        });\n      }));\n    });\n  },\n  watch: {\n    initialIndex: function initialIndex(newIndex) {\n      if (newIndex !== this.currentPageIndex) {\n        this._goToPage(newIndex);\n      }\n    }\n  },\n  methods: {\n    clickItem: function clickItem(item, index) {\n      /* istanbul ignore next */\n      this.$emit(EVENT_SELECT, item, index);\n    },\n    refresh: function refresh() {\n      /* istanbul ignore if */\n      if (this.slide === null) {\n        return;\n      }\n\n      this._destroy();\n\n      clearTimeout(this._timer);\n\n      if (this.slide && this.refreshResetCurrent) {\n        this.currentPageIndex = 0;\n      }\n\n      this._updateSlideDom();\n\n      if (this.showDots) {\n        this._initDots();\n      }\n\n      if (this.currentPageIndex >= this.dots.length) {\n        this.currentPageIndex = this.dots.length - 1;\n      }\n\n      this._initSlide();\n\n      if (this.autoPlay) {\n        this._play();\n      }\n    },\n    _destroy: function _destroy() {\n      this.slide && this.slide.destroy();\n    },\n    _refresh: function _refresh() {\n      this._updateSlideDom(true);\n\n      this.slide.refresh();\n    },\n    _updateSlideDom: function _updateSlideDom(isResize) {\n      this._setSlideStyle(isResize);\n    },\n    _setSlideStyle: function _setSlideStyle(isResize) {\n      this.children = this.$refs.slideGroup.children;\n      var target = this.direction === DIRECTION_H ? 'width' : 'height';\n      var allSize = 0;\n      var slideSize = this.$refs.slide[\"client\".concat(target[0].toUpperCase() + target.slice(1))];\n      var len = this.children.length;\n\n      for (var i = 0; i < len; i++) {\n        var child = this.children[i];\n        child.style[target] = slideSize + 'px';\n        allSize += slideSize;\n      }\n\n      if (this.loop && !isResize && len > 1) {\n        allSize += 2 * slideSize;\n      }\n\n      this.$refs.slideGroup.style[target] = allSize + 'px';\n    },\n    _initSlide: function _initSlide() {\n      var _this2 = this;\n\n      var eventPassthrough = this.direction === DIRECTION_H && this.allowVertical ? DIRECTION_V : '';\n      var options = Object.assign({}, DEFAULT_OPTIONS, {\n        scrollX: this.direction === DIRECTION_H,\n        scrollY: this.direction === DIRECTION_V,\n        eventPassthrough: eventPassthrough,\n        snap: {\n          loop: this.loop,\n          threshold: this.threshold,\n          speed: this.speed\n        },\n        stopPropagation: this.stopPropagation\n      }, this.options);\n      this.slide = new BScroll(this.$refs.slide, options);\n      this.slide.on('scrollEnd', this._onScrollEnd);\n\n      this._goToPage(this.currentPageIndex, 0);\n      /* dispatch scroll position constantly */\n\n\n      if (this.options.listenScroll && this.options.probeType === 3) {\n        this.slide.on('scroll', this._onScroll);\n      }\n\n      var slideEl = this.$refs.slide;\n      slideEl.removeEventListener('touchend', this._touchEndEvent, false);\n\n      this._touchEndEvent = function () {\n        if (_this2.autoPlay) {\n          _this2._play();\n        }\n      };\n\n      slideEl.addEventListener('touchend', this._touchEndEvent, false);\n      this.slide.on('beforeScrollStart', function () {\n        if (_this2.autoPlay) {\n          clearTimeout(_this2._timer);\n        }\n      });\n    },\n    _onScrollEnd: function _onScrollEnd() {\n      var _this$slide$getCurren = this.slide.getCurrentPage(),\n          pageX = _this$slide$getCurren.pageX,\n          pageY = _this$slide$getCurren.pageY;\n\n      var pageIndex = this.direction === DIRECTION_H ? pageX : pageY;\n\n      if (this.currentPageIndex !== pageIndex) {\n        this.currentPageIndex = pageIndex;\n        this.$emit(EVENT_CHANGE, pageIndex);\n      }\n\n      this.$emit(EVENT_SCROLL_END, pageIndex);\n\n      if (this.autoPlay) {\n        this._play();\n      }\n    },\n    _onScroll: function _onScroll(pos) {\n      this.$emit(EVENT_SCROLL, pos);\n    },\n    _initDots: function _initDots() {\n      this.dots = new Array(this.children.length);\n    },\n    _play: function _play() {\n      var _this3 = this;\n\n      clearTimeout(this._timer);\n      this._timer = setTimeout(function () {\n        _this3.slide.next();\n      }, this.interval);\n    },\n    _deactivated: function _deactivated() {\n      clearTimeout(this._timer);\n      clearTimeout(this._resizeTimer);\n      window.removeEventListener('resize', this._resizeHandler);\n      var slideEl = this.$refs.slide;\n\n      if (slideEl) {\n        slideEl.removeEventListener('touchend', this._touchEndEvent, false);\n      }\n    },\n    _resizeHandler: function _resizeHandler() {\n      var _this4 = this;\n\n      /* istanbul ignore if */\n      if (!this.slide) {\n        return;\n      }\n\n      clearTimeout(this._resizeTimer);\n      this._resizeTimer = setTimeout(function () {\n        /* istanbul ignore if */\n        if (_this4.slide.isInTransition) {\n          _this4._onScrollEnd();\n        } else {\n          if (_this4.autoPlay) {\n            _this4._play();\n          }\n        }\n\n        _this4._refresh();\n      }, 60);\n    },\n    _goToPage: function _goToPage(index, time) {\n      if (this.direction === DIRECTION_H) {\n        this.slide && this.slide.goToPage(index, 0, time);\n      } else if (this.direction === DIRECTION_V) {\n        this.slide && this.slide.goToPage(0, index, time);\n      }\n    }\n  },\n  mounted: function mounted() {\n    var _this5 = this;\n\n    this.$nextTick(function () {\n      _this5.refresh();\n    });\n    window.addEventListener('resize', this._resizeHandler);\n  },\n  activated: function activated() {\n    /* istanbul ignore next */\n    if (this.autoPlay) {\n      this._play();\n    }\n\n    window.addEventListener('resize', this._resizeHandler);\n  },\n  deactivated: function deactivated() {\n    /* istanbul ignore next */\n    this._deactivated();\n  },\n  destroyed: function destroyed() {\n    this._deactivated();\n\n    this._destroy();\n\n    this.slide = null;\n\n    this._dataWatchers.forEach(function (cancalWatcher) {\n      cancalWatcher();\n    });\n\n    this._dataWatchers = null;\n  },\n  components: {\n    CubeSlideItem: CubeSlideItem\n  }\n};",null]}