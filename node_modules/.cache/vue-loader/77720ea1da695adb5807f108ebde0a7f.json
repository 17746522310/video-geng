{"remainingRequest":"/Users/wangluna/wln/vueSpace/vue-ergeng/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/wangluna/wln/vueSpace/vue-ergeng/src/components/scroll.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/wangluna/wln/vueSpace/vue-ergeng/src/components/scroll.vue","mtime":1561947615508},{"path":"/Users/wangluna/wln/vueSpace/vue-ergeng/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/wangluna/wln/vueSpace/vue-ergeng/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/wangluna/wln/vueSpace/vue-ergeng/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/wangluna/wln/vueSpace/vue-ergeng/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n\nimport BScroll from 'better-scroll'\n\nexport default {\n    props: {\n        //probeType: 1 滚动的时候会派发scroll事件，会截流。2 滚动的时候实时派发scroll事件，不会截流 3 除了实时派发scroll事件，在swipe的情况下仍然能实时派发scroll事件\n        probeType: {  \n            type: Number, \n            default: 1 \n        },\n        click: {\n            type: Boolean,\n            default: true\n        },\n        data: {\n            type: Array,\n            default: null\n        },\n        listenScroll: {\n            type: Boolean,\n            default: false\n        },\n        //上拉刷新\n        pullup: {\n            type: Boolean,\n            default: true\n        },\n        //是否派发beforeScroll事件\n        beforeScroll: {\n            type: Boolean,\n            default: false\n        },\n        refreshDelay: {\n            type: Number,\n            default: 20\n        }\n    },\n    mounted() {\n        setTimeout(() => {  //确保DOM已经渲染\n            this. _initScroll()\n        }, 20)\n    },\n    methods: {\n        _initScroll() {\n            if(!this.$refs.wrapper){\n                return\n            }\n            this.scroll = new BScroll(this.$refs.wrapper, {\n                probeType : this.probeType,\n                click: this.click\n            })\n\n            if(this.listenScroll) {\n                let me = this            //箭头函数中代理this\n                this.scroll.on('scroll', (pos) => {  //监听scroll事件，拿到pos位置对象：有x和y属性\n                    me.$emit('scroll', pos)\n                })\n            }\n\n            if(this.pullup) { \n               this.scroll.on('scrollEnd', () => {\n                    // 当滚动距离小于等于最大的滚动条的距离 + 50 的时候，向外传递一个scrollToEnd的事件\n                    if(this.scroll.y <= (this.scroll.maxScrollY + 50)) { \n                        this.$emit('scrollToEnd')\n                    }\n               })\n            }\n\n            if(this.beforeScroll) {\n                this.scroll.on('beforeScrollStart', () => {\n                    this.$emit('beforeScroll')\n                })\n            }\n        },\n        enable() {\n            // 启用 better-scroll，默认开启\n            this.scroll && this.scroll.enable()\n        },\n        disable() {\n            // 禁用better-scroll, 如果不加，scroll的高度会高于内容的高度\n            this.scroll && this.scroll.disable()\n        },\n        refresh() {\n            // 强制 scroll 重新计算，当 better-scroll 中的元素发生变化的时候调用此方法\n            this.scroll && this.scroll.refresh()\n        },\n        scrollTo() {\n            // 滚动到指定的位置；这里使用apply 将传入的参数，传入到this.scrollTo()\n            this.scroll && this.scroll.scrollTo.apply(this.scroll, arguments)\n        },\n        scrollToElement() {\n            // 滚动到指定的目标元素\n            this.scroll && this.scroll.scrollToElement.apply(this.scroll, arguments)\n        }\n    },\n    watch: {\n        data() { //监测data的变化\n            setTimeout(() => {\n                this.refresh()\n            }, this.refreshDelay)\n        }\n    }\n}\n",{"version":3,"sources":["scroll.vue"],"names":[],"mappings":";;;;;;;AAOA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"scroll.vue","sourceRoot":"src/components","sourcesContent":["<template>\n    <div ref=\"wrapper\">\n        <slot></slot>\n    </div>\n</template>\n\n<script>\nimport BScroll from 'better-scroll'\n\nexport default {\n    props: {\n        //probeType: 1 滚动的时候会派发scroll事件，会截流。2 滚动的时候实时派发scroll事件，不会截流 3 除了实时派发scroll事件，在swipe的情况下仍然能实时派发scroll事件\n        probeType: {  \n            type: Number, \n            default: 1 \n        },\n        click: {\n            type: Boolean,\n            default: true\n        },\n        data: {\n            type: Array,\n            default: null\n        },\n        listenScroll: {\n            type: Boolean,\n            default: false\n        },\n        //上拉刷新\n        pullup: {\n            type: Boolean,\n            default: true\n        },\n        //是否派发beforeScroll事件\n        beforeScroll: {\n            type: Boolean,\n            default: false\n        },\n        refreshDelay: {\n            type: Number,\n            default: 20\n        }\n    },\n    mounted() {\n        setTimeout(() => {  //确保DOM已经渲染\n            this. _initScroll()\n        }, 20)\n    },\n    methods: {\n        _initScroll() {\n            if(!this.$refs.wrapper){\n                return\n            }\n            this.scroll = new BScroll(this.$refs.wrapper, {\n                probeType : this.probeType,\n                click: this.click\n            })\n\n            if(this.listenScroll) {\n                let me = this            //箭头函数中代理this\n                this.scroll.on('scroll', (pos) => {  //监听scroll事件，拿到pos位置对象：有x和y属性\n                    me.$emit('scroll', pos)\n                })\n            }\n\n            if(this.pullup) { \n               this.scroll.on('scrollEnd', () => {\n                    // 当滚动距离小于等于最大的滚动条的距离 + 50 的时候，向外传递一个scrollToEnd的事件\n                    if(this.scroll.y <= (this.scroll.maxScrollY + 50)) { \n                        this.$emit('scrollToEnd')\n                    }\n               })\n            }\n\n            if(this.beforeScroll) {\n                this.scroll.on('beforeScrollStart', () => {\n                    this.$emit('beforeScroll')\n                })\n            }\n        },\n        enable() {\n            // 启用 better-scroll，默认开启\n            this.scroll && this.scroll.enable()\n        },\n        disable() {\n            // 禁用better-scroll, 如果不加，scroll的高度会高于内容的高度\n            this.scroll && this.scroll.disable()\n        },\n        refresh() {\n            // 强制 scroll 重新计算，当 better-scroll 中的元素发生变化的时候调用此方法\n            this.scroll && this.scroll.refresh()\n        },\n        scrollTo() {\n            // 滚动到指定的位置；这里使用apply 将传入的参数，传入到this.scrollTo()\n            this.scroll && this.scroll.scrollTo.apply(this.scroll, arguments)\n        },\n        scrollToElement() {\n            // 滚动到指定的目标元素\n            this.scroll && this.scroll.scrollToElement.apply(this.scroll, arguments)\n        }\n    },\n    watch: {\n        data() { //监测data的变化\n            setTimeout(() => {\n                this.refresh()\n            }, this.refreshDelay)\n        }\n    }\n}\n</script>\n\n<style lang=\"less\" scoped>\n\n</style>\n"]}]}